
<!DOCTYPE html><html><head>
<title>clay - Clay Framework</title>
<style type="text/css"><!--
    HTML {
	background: 	#FFFFFF;
	color: 		black;
    }
    BODY {
	background: 	#FFFFFF;
	color:	 	black;
    }
    DIV.doctools {
	margin-left:	10%;
	margin-right:	10%;
    }
    DIV.doctools H1,DIV.doctools H2 {
	margin-left:	-5%;
    }
    H1, H2, H3, H4 {
	margin-top: 	1em;
	font-family:	sans-serif;
	font-size:	large;
	color:		#005A9C;
	background: 	transparent;
	text-align:		left;
    }
    H1.doctools_title {
	text-align: center;
    }
    UL,OL {
	margin-right: 0em;
	margin-top: 3pt;
	margin-bottom: 3pt;
    }
    UL LI {
	list-style: disc;
    }
    OL LI {
	list-style: decimal;
    }
    DT {
	padding-top: 	1ex;
    }
    UL.doctools_toc,UL.doctools_toc UL, UL.doctools_toc UL UL {
	font:		normal 12pt/14pt sans-serif;
	list-style:	none;
    }
    LI.doctools_section, LI.doctools_subsection {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding: 	0em;
    }
    PRE {
	display: 	block;
	font-family:	monospace;
	white-space:	pre;
	margin:		0%;
	padding-top:	0.5ex;
	padding-bottom:	0.5ex;
	padding-left:	1ex;
	padding-right:	1ex;
	width:		100%;
    }
    PRE.doctools_example {
	color: 		black;
	background: 	#f5dcb3;
	border:		1px solid black;
    }
    UL.doctools_requirements LI, UL.doctools_syntax LI {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding:	0em;
    }
    DIV.doctools_synopsis {
	color: 		black;
	background: 	#80ffff;
	border:		1px solid black;
	font-family:	serif;
	margin-top: 	1em;
	margin-bottom: 	1em;
    }
    UL.doctools_syntax {
	margin-top: 	1em;
	border-top:	1px solid black;
    }
    UL.doctools_requirements {
	margin-bottom: 	1em;
	border-bottom:	1px solid black;
    }
--></style>
</head>
<!-- Generated from file 'clay.man' by tcllib/doctools with format 'html'
   -->
<!-- Copyright &amp;copy; 2018 Sean Woods &amp;lt;yoda@etoyoc.com&amp;gt;
   -->
<!-- clay.n
   -->
<body><div class="doctools">
<h1 class="doctools_title">clay(n) 0.3 clay &quot;Clay Framework&quot;</h1>
<div id="name" class="doctools_section"><h2><a name="name">Name</a></h2>
<p>clay - A minimalist framework for large scale OO Projects</p>
</div>
<div id="toc" class="doctools_section"><h2><a name="toc">Table Of Contents</a></h2>
<ul class="doctools_toc">
<li class="doctools_section"><a href="#toc">Table Of Contents</a></li>
<li class="doctools_section"><a href="#synopsis">Synopsis</a></li>
<li class="doctools_section"><a href="#section1">Description</a>
<ul>
<li class="doctools_subsection"><a href="#subsection1">Structured Data</a></li>
<li class="doctools_subsection"><a href="#subsection2">Clay Dialect</a></li>
<li class="doctools_subsection"><a href="#subsection3">Method Delegation</a></li>
</ul>
</li>
<li class="doctools_section"><a href="#section2">Commands</a></li>
<li class="doctools_section"><a href="#section3">Classes</a>
<ul>
<li class="doctools_subsection"><a href="#subsection4">Class  oo::class</a></li>
<li class="doctools_subsection"><a href="#subsection5">Class  oo::object</a></li>
<li class="doctools_subsection"><a href="#subsection6">Class  clay::object</a></li>
<li class="doctools_subsection"><a href="#subsection7">Class  clay::doctool</a></li>
</ul>
</li>
<li class="doctools_section"><a href="#section4">AUTHORS</a></li>
<li class="doctools_section"><a href="#section5">Bugs, Ideas, Feedback</a></li>
<li class="doctools_section"><a href="#keywords">Keywords</a></li>
<li class="doctools_section"><a href="#category">Category</a></li>
<li class="doctools_section"><a href="#copyright">Copyright</a></li>
</ul>
</div>
<div id="synopsis" class="doctools_section"><h2><a name="synopsis">Synopsis</a></h2>
<div class="doctools_synopsis">
<ul class="doctools_requirements">
<li>package require <b class="pkgname">Tcl 8.6</b></li>
<li>package require <b class="pkgname">uuid</b></li>
<li>package require <b class="pkgname">oo::dialect</b></li>
</ul>
<ul class="doctools_syntax">
<li><a href="#1">proc <b class="cmd">putb</b> <span class="opt">?<i class="arg">map</i>?</span> <i class="arg">text</i></a></li>
<li><a href="#2">proc <b class="cmd">clay::ancestors</b> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#3">proc <b class="cmd">clay::args_to_dict</b> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#4">proc <b class="cmd">clay::args_to_options</b> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#5">proc <b class="cmd">clay::dictmerge</b> <i class="arg">varname</i> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#6">proc <b class="cmd">clay::_dictmerge</b> <i class="arg">a</i> <i class="arg">b</i></a></li>
<li><a href="#7">proc <b class="cmd">clay::dictputb</b> <i class="arg">dict</i></a></li>
<li><a href="#8">proc <b class="cmd">clay::_dictputb</b> <i class="arg">leaf</i> <i class="arg">level</i> <i class="arg">varname</i> <i class="arg">dict</i></a></li>
<li><a href="#9">proc <b class="cmd">clay::dynamic_arguments</b> <i class="arg">ensemble</i> <i class="arg">method</i> <i class="arg">arglist</i> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#10">proc <b class="cmd">clay::dynamic_wrongargs_message</b> <i class="arg">arglist</i></a></li>
<li><a href="#11">proc <b class="cmd">clay::is_dict</b> <i class="arg">d</i></a></li>
<li><a href="#12">proc <b class="cmd">clay::is_null</b> <i class="arg">value</i></a></li>
<li><a href="#13">proc <b class="cmd">clay::leaf</b> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#14">proc <b class="cmd">clay::path</b> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#15">proc <b class="cmd">clay::script_path</b></a></li>
<li><a href="#16">proc <b class="cmd">clay::NSNormalize</b> <i class="arg">qualname</i></a></li>
<li><a href="#17">proc <b class="cmd">clay::uuid_generate</b> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#18">proc <b class="cmd">clay::dynamic_methods</b> <i class="arg">class</i></a></li>
<li><a href="#19">proc <b class="cmd">clay::dynamic_methods_class</b> <i class="arg">thisclass</i></a></li>
<li><a href="#20">proc <b class="cmd">clay::define::Array</b> <i class="arg">name</i> <span class="opt">?<i class="arg">values</i> <b class="const"></b>?</span></a></li>
<li><a href="#21">proc <b class="cmd">clay::define::component</b> <i class="arg">name</i> <i class="arg">info</i></a></li>
<li><a href="#22">proc <b class="cmd">clay::define::constructor</b> <i class="arg">arglist</i> <i class="arg">rawbody</i></a></li>
<li><a href="#23">proc <b class="cmd">clay::define::class_method</b> <i class="arg">name</i> <i class="arg">arglist</i> <i class="arg">body</i></a></li>
<li><a href="#24">proc <b class="cmd">clay::define::clay</b> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#25">proc <b class="cmd">clay::define::destructor</b> <i class="arg">rawbody</i></a></li>
<li><a href="#26">proc <b class="cmd">clay::define::Dict</b> <i class="arg">name</i> <span class="opt">?<i class="arg">values</i> <b class="const"></b>?</span></a></li>
<li><a href="#27">proc <b class="cmd">clay::define::Variable</b> <i class="arg">name</i> <span class="opt">?<i class="arg">default</i> <b class="const"></b>?</span></a></li>
<li><a href="#28">proc <b class="cmd">clay::object_create</b> <i class="arg">objname</i> <span class="opt">?<i class="arg">class</i> <b class="const"></b>?</span></a></li>
<li><a href="#29">proc <b class="cmd">clay::object_rename</b> <i class="arg">object</i> <i class="arg">newname</i></a></li>
<li><a href="#30">proc <b class="cmd">clay::object_destroy</b> <i class="arg">objname</i></a></li>
<li><a href="#31">proc <b class="cmd">clay::ensemble_methodbody</b> <i class="arg">ensemble</i> <i class="arg">einfo</i></a></li>
<li><a href="#32">proc <b class="cmd">clay::define::Ensemble</b> <i class="arg">rawmethod</i> <i class="arg">arglist</i> <i class="arg">body</i></a></li>
<li><a href="#33">proc <b class="cmd">clay::cat</b> <i class="arg">fname</i></a></li>
<li><a href="#34">proc <b class="cmd">clay::docstrip</b> <i class="arg">text</i></a></li>
<li><a href="#35">method <b class="cmd">clay ancestors</b></a></li>
<li><a href="#36">method <b class="cmd">clay dump</b></a></li>
<li><a href="#37">method <b class="cmd">clay get</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span></a></li>
<li><a href="#38">method <b class="cmd">clay merge</b> <i class="arg">dict</i> <span class="opt">?<b class="option">dict...</b>?</span></a></li>
<li><a href="#39">method <b class="cmd">clay replace</b> <i class="arg">dictionary</i></a></li>
<li><a href="#40">method <b class="cmd">clay search</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span></a></li>
<li><a href="#41">method <b class="cmd">clay set</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span> <i class="arg">value</i></a></li>
<li><a href="#42">method <b class="cmd">clay ancestors</b></a></li>
<li><a href="#43">method <b class="cmd">clay cget</b> <i class="arg">field</i></a></li>
<li><a href="#44">method <b class="cmd">clay delegate</b> <span class="opt">?<i class="arg">stub</i>?</span> <span class="opt">?<i class="arg">object</i>?</span></a></li>
<li><a href="#45">method <b class="cmd">clay dump</b></a></li>
<li><a href="#46">method <b class="cmd">clay ensemble_map</b></a></li>
<li><a href="#47">method <b class="cmd">clay eval</b> <i class="arg">script</i></a></li>
<li><a href="#48">method <b class="cmd">clay evolve</b></a></li>
<li><a href="#49">method <b class="cmd">clay exists</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span></a></li>
<li><a href="#50">method <b class="cmd">clay flush</b></a></li>
<li><a href="#51">method <b class="cmd">clay forward</b> <i class="arg">method</i> <i class="arg">object</i></a></li>
<li><a href="#52">method <b class="cmd">clay get</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span></a></li>
<li><a href="#53">method <b class="cmd">clay leaf</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span></a></li>
<li><a href="#54">method <b class="cmd">clay merge</b> <i class="arg">dict</i> <span class="opt">?<b class="option">dict...</b>?</span></a></li>
<li><a href="#55">method <b class="cmd">clay mixin</b> <i class="arg">class</i> <span class="opt">?<b class="option">class...</b>?</span></a></li>
<li><a href="#56">method <b class="cmd">clay mixinmap</b> <span class="opt">?<i class="arg">stub</i>?</span> <span class="opt">?<i class="arg">classes</i>?</span></a></li>
<li><a href="#57">method <b class="cmd">clay provenance</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span></a></li>
<li><a href="#58">method <b class="cmd">clay replace</b> <i class="arg">dictionary</i></a></li>
<li><a href="#59">method <b class="cmd">clay source</b> <i class="arg">filename</i></a></li>
<li><a href="#60">method <b class="cmd">clay set</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span> <i class="arg">value</i></a></li>
<li><a href="#61">method <b class="cmd">InitializePublic</b></a></li>
<li><a href="#62">method <b class="cmd">InitializePublic</b></a></li>
<li><a href="#63">method <b class="cmd">constructor</b></a></li>
<li><a href="#64">method <b class="cmd">arglist</b> <i class="arg">arglist</i></a></li>
<li><a href="#65">method <b class="cmd">comment</b> <i class="arg">block</i></a></li>
<li><a href="#66">method <b class="cmd">keyword.Class</b> <i class="arg">resultvar</i> <i class="arg">commentblock</i> <i class="arg">name</i> <i class="arg">body</i></a></li>
<li><a href="#67">method <b class="cmd">keyword.class</b> <i class="arg">resultvar</i> <i class="arg">commentblock</i> <i class="arg">name</i> <i class="arg">body</i></a></li>
<li><a href="#68">method <b class="cmd">keyword.class_method</b> <i class="arg">resultvar</i> <i class="arg">commentblock</i> <i class="arg">name</i> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#69">method <b class="cmd">keyword.method</b> <i class="arg">resultvar</i> <i class="arg">commentblock</i> <i class="arg">name</i> <span class="opt">?<i class="arg">args</i>?</span></a></li>
<li><a href="#70">method <b class="cmd">keyword.proc</b> <i class="arg">commentblock</i> <i class="arg">name</i> <i class="arg">arglist</i> <i class="arg">body</i></a></li>
<li><a href="#71">method <b class="cmd">reset</b></a></li>
<li><a href="#72">method <b class="cmd">Main</b></a></li>
<li><a href="#73">method <b class="cmd">section.method</b> <i class="arg">keyword</i> <i class="arg">method</i> <i class="arg">minfo</i></a></li>
<li><a href="#74">method <b class="cmd">section.class</b> <i class="arg">class_name</i> <i class="arg">class_info</i></a></li>
<li><a href="#75">method <b class="cmd">section.command</b> <i class="arg">procinfo</i></a></li>
<li><a href="#76">method <b class="cmd">manpage</b> <span class="opt">?<b class="option">header <em>value</em></b>?</span> <span class="opt">?<b class="option">footer <em>value</em></b>?</span> <span class="opt">?<b class="option">authors <em>list</em></b>?</span></a></li>
<li><a href="#77">method <b class="cmd">scan_text</b> <i class="arg">text</i></a></li>
<li><a href="#78">method <b class="cmd">scan_file</b> <i class="arg">filename</i></a></li>
</ul>
</div>
</div>
<div id="section1" class="doctools_section"><h2><a name="section1">Description</a></h2>
<p>Clay introduces a method ensemble to both <b class="class">oo::class</b> and <b class="class">oo::object</b> called
clay. This ensemble handles all of the high level interactions within the framework.
Clay stores structured data. Clan manages method delegation. Clay has facilities to
manage the complex interactions that come about with mixins.</p>
<p>The central concept is that inside of every object and class
(which are actually objects too) is a dict called clay. What is stored in that dict is
left to the imagination. But because this dict is exposed via a public method, we can
share structured data between object, classes, and mixins.</p>
<div id="subsection1" class="doctools_subsection"><h3><a name="subsection1">Structured Data</a></h3>
<p>Clay uses a standardized set of method interactions and introspection that TclOO already provides to perform on-the-fly searches. On-the-fly searches mean that the data is never stale, and we avoid many of the sorts of collisions that would arise when objects start mixing in other classes during operation.</p>
<p>The <b class="method">clay</b> methods for both classes and objects have a get and a set method. For objects, get will search through the local clay dict. If the requested leaf is not found, or the query is for a branch, the system will then begin to poll the clay methods of all of the class that implements the object, all of that classes’ ancestors, as well as all of the classes that have been mixed into this object, and all of their ancestors.</p>
<p>Intended branches on a tree end with a directory slash (/). Intended leaves are left unadorned. This is a guide for the tool that builds the search
results to know what parts of a dict are intended to be branches and which are intended to be leaves.
For simple cases, branch marking can be ignored:</p>
<pre class="doctools_example">
::oo::class create ::foo { }
::foo clay set property/ color blue
::foo clay set property/ shape round
set A [::foo new]
$A clay get property/
{color blue shape round}
$A clay set property/ shape square
$A clay get property/
{color blue shape square}
</pre>
<p>But when you start storing blocks of text, guessing what field is a dict and what isn’t gets messy:</p>
<pre class="doctools_example">
::foo clay set description {A generic thing of designated color and shape}
$A clay get description
{A generic thing of designated color and shape}
Without a convention for discerning branches for leaves what should have been a value can be accidentally parsed as a dictionary, and merged with all of the other values that were never intended to be merge. Here is an example of it all going wrong:
::oo::class create ::foo { }
# Add description as a leaf
::foo clay set description  {A generic thing of designated color and shape}
# Add description as a branch
::foo clay set description/  {A generic thing of designated color and shape}
::oo::class create ::bar {
  superclass foo
}
# Add description as a leaf
::bar clay set description  {A drinking establishment of designated color and shape and size}
# Add description as a branch
::bar clay set description/  {A drinking establishment of designated color and shape and size}
set B [::bar new]
# As a leaf we get the value verbatim from he nearest ancestor
$B clay get description
  {A drinking establishment of designated color and shape and size}
# As a branch we get a recursive merge
$B clay get description/
{A drinking establishment of designated color and size thing of}
</pre>
</div>
<div id="subsection2" class="doctools_subsection"><h3><a name="subsection2">Clay Dialect</a></h3>
<p>Clay is built using the oo::dialect module from Tcllib. oo::dialect allows you to either add keywords directly to clay, or to create your own
metaclass and keyword set using Clay as a foundation. For details on the keywords and what they do, consult the functions in the ::clay::define namespace.</p>
</div>
<div id="subsection3" class="doctools_subsection"><h3><a name="subsection3">Method Delegation</a></h3>
<p>Method Delegation
It is sometimes useful to have an external object that can be invoked as if it were a method of the object. Clay provides a delegate ensemble method to perform that delegation, as well as introspect which methods are delegated in that manner. All delegated methods are marked with html-like tag markings (&lt; &gt;) around them.</p>
<pre class="doctools_example">
::clay::define counter {
  Variable counter 0
  method incr {{howmuch 1}} {
    my variable counter
    incr counter $howmuch
  }
  method value {} {
    my variable counter
    return $counter
  }
  method reset {} {
    my variable counter
    set counter 0
  }
}
::clay::define example {
  variable buffer
  constructor {} {
    # Build a counter object
    set obj [namespace current]::counter
    ::counter create $obj
    # Delegate the counter
    my delegate &lt;counter&gt; $obj
  }
  method line {text} {
    my &lt;counter&gt; incr
    append buffer $text
  }
}
set A [example new]
$A line {Who’s line is it anyway?}
$A &lt;counter&gt; value
1
</pre>
</div>
</div>
<div id="section2" class="doctools_section"><h2><a name="section2">Commands</a></h2>
<dl class="doctools_definitions">
<dt><a name="1">proc <b class="cmd">putb</b> <span class="opt">?<i class="arg">map</i>?</span> <i class="arg">text</i></a></dt>
<dd><p>Append a line of text to a variable. Optionally apply a string mapping.</p></dd>
<dt><a name="2">proc <b class="cmd">clay::ancestors</b> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd></dd>
<dt><a name="3">proc <b class="cmd">clay::args_to_dict</b> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd></dd>
<dt><a name="4">proc <b class="cmd">clay::args_to_options</b> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd></dd>
<dt><a name="5">proc <b class="cmd">clay::dictmerge</b> <i class="arg">varname</i> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd></dd>
<dt><a name="6">proc <b class="cmd">clay::_dictmerge</b> <i class="arg">a</i> <i class="arg">b</i></a></dt>
<dd></dd>
<dt><a name="7">proc <b class="cmd">clay::dictputb</b> <i class="arg">dict</i></a></dt>
<dd></dd>
<dt><a name="8">proc <b class="cmd">clay::_dictputb</b> <i class="arg">leaf</i> <i class="arg">level</i> <i class="arg">varname</i> <i class="arg">dict</i></a></dt>
<dd></dd>
<dt><a name="9">proc <b class="cmd">clay::dynamic_arguments</b> <i class="arg">ensemble</i> <i class="arg">method</i> <i class="arg">arglist</i> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd></dd>
<dt><a name="10">proc <b class="cmd">clay::dynamic_wrongargs_message</b> <i class="arg">arglist</i></a></dt>
<dd></dd>
<dt><a name="11">proc <b class="cmd">clay::is_dict</b> <i class="arg">d</i></a></dt>
<dd></dd>
<dt><a name="12">proc <b class="cmd">clay::is_null</b> <i class="arg">value</i></a></dt>
<dd></dd>
<dt><a name="13">proc <b class="cmd">clay::leaf</b> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd></dd>
<dt><a name="14">proc <b class="cmd">clay::path</b> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd></dd>
<dt><a name="15">proc <b class="cmd">clay::script_path</b></a></dt>
<dd></dd>
<dt><a name="16">proc <b class="cmd">clay::NSNormalize</b> <i class="arg">qualname</i></a></dt>
<dd></dd>
<dt><a name="17">proc <b class="cmd">clay::uuid_generate</b> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd></dd>
<dt><a name="18">proc <b class="cmd">clay::dynamic_methods</b> <i class="arg">class</i></a></dt>
<dd></dd>
<dt><a name="19">proc <b class="cmd">clay::dynamic_methods_class</b> <i class="arg">thisclass</i></a></dt>
<dd></dd>
<dt><a name="20">proc <b class="cmd">clay::define::Array</b> <i class="arg">name</i> <span class="opt">?<i class="arg">values</i> <b class="const"></b>?</span></a></dt>
<dd><p>New OO Keywords for clay</p></dd>
<dt><a name="21">proc <b class="cmd">clay::define::component</b> <i class="arg">name</i> <i class="arg">info</i></a></dt>
<dd></dd>
<dt><a name="22">proc <b class="cmd">clay::define::constructor</b> <i class="arg">arglist</i> <i class="arg">rawbody</i></a></dt>
<dd></dd>
<dt><a name="23">proc <b class="cmd">clay::define::class_method</b> <i class="arg">name</i> <i class="arg">arglist</i> <i class="arg">body</i></a></dt>
<dd></dd>
<dt><a name="24">proc <b class="cmd">clay::define::clay</b> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd></dd>
<dt><a name="25">proc <b class="cmd">clay::define::destructor</b> <i class="arg">rawbody</i></a></dt>
<dd></dd>
<dt><a name="26">proc <b class="cmd">clay::define::Dict</b> <i class="arg">name</i> <span class="opt">?<i class="arg">values</i> <b class="const"></b>?</span></a></dt>
<dd></dd>
<dt><a name="27">proc <b class="cmd">clay::define::Variable</b> <i class="arg">name</i> <span class="opt">?<i class="arg">default</i> <b class="const"></b>?</span></a></dt>
<dd><p>This keyword can also be expressed:</p>
<pre class="doctools_example">property variable NAME {default DEFAULT}</pre>
<p>Variables registered in the variable property are also initialized
    (if missing) when the object changes class via the <em>morph</em> method.</p></dd>
<dt><a name="28">proc <b class="cmd">clay::object_create</b> <i class="arg">objname</i> <span class="opt">?<i class="arg">class</i> <b class="const"></b>?</span></a></dt>
<dd></dd>
<dt><a name="29">proc <b class="cmd">clay::object_rename</b> <i class="arg">object</i> <i class="arg">newname</i></a></dt>
<dd></dd>
<dt><a name="30">proc <b class="cmd">clay::object_destroy</b> <i class="arg">objname</i></a></dt>
<dd></dd>
<dt><a name="31">proc <b class="cmd">clay::ensemble_methodbody</b> <i class="arg">ensemble</i> <i class="arg">einfo</i></a></dt>
<dd></dd>
<dt><a name="32">proc <b class="cmd">clay::define::Ensemble</b> <i class="arg">rawmethod</i> <i class="arg">arglist</i> <i class="arg">body</i></a></dt>
<dd></dd>
<dt><a name="33">proc <b class="cmd">clay::cat</b> <i class="arg">fname</i></a></dt>
<dd><p>Concatenate a file</p></dd>
<dt><a name="34">proc <b class="cmd">clay::docstrip</b> <i class="arg">text</i></a></dt>
<dd><p>Strip the global comments from tcl code. Used to
 prevent the documentation markup comments from clogging
 up files intended for distribution in machine readable format.</p></dd>
</dl>
</div>
<div id="section3" class="doctools_section"><h2><a name="section3">Classes</a></h2>
<div id="subsection4" class="doctools_subsection"><h3><a name="subsection4">Class  oo::class</a></h3>
<p><b class="class">Methods</b></p>
<dl class="doctools_definitions">
<dt><a name="35">method <b class="cmd">clay ancestors</b></a></dt>
<dd><p>Return this class and all ancestors in search order.</p></dd>
<dt><a name="36">method <b class="cmd">clay dump</b></a></dt>
<dd><p>Return a complete dump of this object's clay data, but only this object's clay data.</p></dd>
<dt><a name="37">method <b class="cmd">clay get</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span></a></dt>
<dd><p>Pull a chunk of data from the clay system. If the last element of <em>path</em> is a branch (ends in a slash /),
     returns a recursive merge of all data from this object and it's constituent classes of the data in that branch.
     If the last element is a leaf, search this object for a matching leaf, or search all  constituent classes for a matching
     leaf and return the first value found.
     If no value is found, returns an empty string.</p></dd>
<dt><a name="38">method <b class="cmd">clay merge</b> <i class="arg">dict</i> <span class="opt">?<b class="option">dict...</b>?</span></a></dt>
<dd><p>Recursively merge the dictionaries given into the object's local clay storage.</p></dd>
<dt><a name="39">method <b class="cmd">clay replace</b> <i class="arg">dictionary</i></a></dt>
<dd><p>Replace the contents of the internal clay storage with the dictionary given.</p></dd>
<dt><a name="40">method <b class="cmd">clay search</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span></a></dt>
<dd><p>Return the first matching value for the path in either this class's clay data or one of its ancestors</p></dd>
<dt><a name="41">method <b class="cmd">clay set</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span> <i class="arg">value</i></a></dt>
<dd><p>Merge the conents of <b class="const">value</b> with the object's clay storage at <b class="const">path</b>.</p></dd>
</dl>
</div>
<div id="subsection5" class="doctools_subsection"><h3><a name="subsection5">Class  oo::object</a></h3>
<p><b class="class">Methods</b></p>
<dl class="doctools_definitions">
<dt><a name="42">method <b class="cmd">clay ancestors</b></a></dt>
<dd><p>Return the class this object belongs to, all classes mixed into this object, and all ancestors of those classes in search order.</p></dd>
<dt><a name="43">method <b class="cmd">clay cget</b> <i class="arg">field</i></a></dt>
<dd><p>Pull a value from either the object's clay structure or one of its constituent classes that matches the field name.
 The order of search us:</p>
<p>1. The as a value in local dict variable config</p>
<p>2. The as a value in local dict variable clay</p>
<p>3. As a leaf in any ancestor as a root of the clay tree</p>
<p>4. As a leaf in any ancestor under the const/ branch of the clay tree</p></dd>
<dt><a name="44">method <b class="cmd">clay delegate</b> <span class="opt">?<i class="arg">stub</i>?</span> <span class="opt">?<i class="arg">object</i>?</span></a></dt>
<dd><p>Introspect or control method delegation. With no arguments, the method will return a
 key/value list of stubs and objects. With just the <i class="arg">stub</i> argument, the method will
 return the object (if any) attached to the stub. With a <i class="arg">stub</i> and an <i class="arg">object</i>
 this command will forward all calls to the method <i class="arg">stub</i> to the <i class="arg">object</i>.</p></dd>
<dt><a name="45">method <b class="cmd">clay dump</b></a></dt>
<dd><p>Return a complete dump of this object's clay data, as well as the data from all constituent classes recursively blended in.</p></dd>
<dt><a name="46">method <b class="cmd">clay ensemble_map</b></a></dt>
<dd><p>Return a dictionary describing the method ensembles to be assembled for this object</p></dd>
<dt><a name="47">method <b class="cmd">clay eval</b> <i class="arg">script</i></a></dt>
<dd><p>Evaluated a script in the namespace of this object</p></dd>
<dt><a name="48">method <b class="cmd">clay evolve</b></a></dt>
<dd><p>Trigger the <b class="method">InitializePublic</b> private method</p></dd>
<dt><a name="49">method <b class="cmd">clay exists</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span></a></dt>
<dd><p>Returns 1 if <em>path</em> exists in either the object's clay data. Values greater than one indicate the element exists in one of the object's constituent classes. A value of zero indicates the path could not be found.</p></dd>
<dt><a name="50">method <b class="cmd">clay flush</b></a></dt>
<dd><p>Wipe any caches built by the clay implementation</p></dd>
<dt><a name="51">method <b class="cmd">clay forward</b> <i class="arg">method</i> <i class="arg">object</i></a></dt>
<dd><p>A convenience wrapper for</p>
<pre class="doctools_example">oo::objdefine [self] forward {*}$args</pre>
</dd>
<dt><a name="52">method <b class="cmd">clay get</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span></a></dt>
<dd><p>Pull a chunk of data from the clay system. If the last element of <em>path</em> is a branch (ends in a slash /),
   returns a recursive merge of all data from this object and it's constituent classes of the data in that branch.
   If the last element is a leaf, search this object for a matching leaf, or search all  constituent classes for a matching
   leaf and return the first value found.
   If no value is found, returns an empty string.</p></dd>
<dt><a name="53">method <b class="cmd">clay leaf</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span></a></dt>
<dd><p>A modified get which is tailored to pull only leaf elements</p></dd>
<dt><a name="54">method <b class="cmd">clay merge</b> <i class="arg">dict</i> <span class="opt">?<b class="option">dict...</b>?</span></a></dt>
<dd><p>Recursively merge the dictionaries given into the object's local clay storage.</p></dd>
<dt><a name="55">method <b class="cmd">clay mixin</b> <i class="arg">class</i> <span class="opt">?<b class="option">class...</b>?</span></a></dt>
<dd><p>Perform [oo::objdefine [self] mixin] on this object, with a few additional rules:
   Prior to the call, for any class was previously mixed in, but not in the new result, execute the script registered to mixin/ unmap-script (if given.)
   For all new classes, that were not present prior to this call, after the native TclOO mixin is invoked, execute the script registered to mixin/ map-script (if given.)
   Fall all classes that are now present and “mixed in”, execute the script registered to mixin/ react-script (if given.)</p></dd>
<dt><a name="56">method <b class="cmd">clay mixinmap</b> <span class="opt">?<i class="arg">stub</i>?</span> <span class="opt">?<i class="arg">classes</i>?</span></a></dt>
<dd><p>With no arguments returns the map of stubs and classes mixed into the current object. When only stub is given,
  returns the classes mixed in on that stub. When stub and classlist given, replace the classes currently on that stub with the given
  classes and invoke clay mixin on the new matrix of mixed in classes.</p></dd>
<dt><a name="57">method <b class="cmd">clay provenance</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span></a></dt>
<dd><p>Return either <b class="const">self</b> if that path exists in the current object, or return the first class (if any) along the clay search path which contains that element.</p></dd>
<dt><a name="58">method <b class="cmd">clay replace</b> <i class="arg">dictionary</i></a></dt>
<dd><p>Replace the contents of the internal clay storage with the dictionary given.</p></dd>
<dt><a name="59">method <b class="cmd">clay source</b> <i class="arg">filename</i></a></dt>
<dd><p>Source the given filename within the object's namespace</p></dd>
<dt><a name="60">method <b class="cmd">clay set</b> <i class="arg">path</i> <span class="opt">?<b class="option">path...</b>?</span> <i class="arg">value</i></a></dt>
<dd><p>Merge the conents of <b class="const">value</b> with the object's clay storage at <b class="const">path</b>.</p></dd>
<dt><a name="61">method <b class="cmd">InitializePublic</b></a></dt>
<dd><p>Instantiate variables. Called on object creation and during clay mixin.</p></dd>
</dl>
</div>
<div id="subsection6" class="doctools_subsection"><h3><a name="subsection6">Class  clay::object</a></h3>
<p>clay::object
 This class is inherited by all classes that have options.</p>
<p><b class="class">Methods</b></p>
<dl class="doctools_definitions">
<dt><a name="62">method <b class="cmd">InitializePublic</b></a></dt>
<dd><p>Instantiate variables and build ensemble methods.</p></dd>
</dl>
</div>
<div id="subsection7" class="doctools_subsection"><h3><a name="subsection7">Class  clay::doctool</a></h3>
<pre class="doctools_example">{ set authors {
   {John Doe} {jdoe@illustrious.edu}
   {Tom RichardHarry} {tomdickharry@illustrius.edu}
 }
 # Create the object
 ::clay::doctool create AutoDoc
 set fout [open [file join $moddir module.tcl] w]
 foreach file [glob [file join $srcdir *.tcl]] {
   set content [::clay::cat [file join $srcdir $file]]
    # Scan the file
    AutoDoc scan_text $content
    # Strip the comments from the distribution
    puts $fout [::clay::docstrip $content]
 }
 # Write out the manual page
 set manout [open [file join $moddir module.man] w]
 dict set arglist header [string map $modmap [::clay::cat [file join $srcdir manual.txt]]]
 dict set arglist footer [string map $modmap [::clay::cat [file join $srcdir footer.txt]]]
 dict set arglist authors $authors
 puts $manout [AutoDoc manpage {*}$arglist]
 close $manout
}</pre>
<p>Tool for build scripts to dynamically generate manual files from comments
 in source code files</p>
<p><b class="class">Methods</b></p>
<dl class="doctools_definitions">
<dt><a name="63">method <b class="cmd">constructor</b></a></dt>
<dd></dd>
<dt><a name="64">method <b class="cmd">arglist</b> <i class="arg">arglist</i></a></dt>
<dd><p>Process an argument list into an informational dict.
 This method also understands non-positional
 arguments expressed in the notation of Tip 471
 <a href="https://core.tcl-lang.org/tips/doc/trunk/tip/479.md">https://core.tcl-lang.org/tips/doc/trunk/tip/479.md</a>.</p>
<p>The output will be a dictionary of all of the fields and whether the fields
 are <b class="const">positional</b>, <b class="const">mandatory</b>, and whether they have a
 <b class="const">default</b> value.</p>
<p>Example:</p>
<pre class="doctools_example">   my arglist {a b {c 10}}
   &gt; a {positional 1 mandatory 1} b {positional 1 mandatory 1} c {positional 1 mandatory 0 default 10}
</pre>
</dd>
<dt><a name="65">method <b class="cmd">comment</b> <i class="arg">block</i></a></dt>
<dd><p>Convert a block of comments into an informational dictionary.
 If lines in the comment start with a single word ending in a colon,
 all subsequent lines are appended to a dictionary field of that name.
 If no fields are given, all of the text is appended to the <b class="const">description</b>
 field.</p>
<p>Example:</p>
<pre class="doctools_example"> my comment {Does something cool}
 &gt; description {Does something cool}
 my comment {
 title : Something really cool
 author : Sean Woods
 author : John Doe
 description :
 This does something really cool!
 }
 &gt; description {This does something really cool!}
   title {Something really cool}
   author {Sean Woods
   John Doe}
</pre>
</dd>
<dt><a name="66">method <b class="cmd">keyword.Class</b> <i class="arg">resultvar</i> <i class="arg">commentblock</i> <i class="arg">name</i> <i class="arg">body</i></a></dt>
<dd><p>Process an oo::objdefine call that modifies the class object
 itself</p></dd>
<dt><a name="67">method <b class="cmd">keyword.class</b> <i class="arg">resultvar</i> <i class="arg">commentblock</i> <i class="arg">name</i> <i class="arg">body</i></a></dt>
<dd><p>Process an oo::define, clay::define, etc statement.</p></dd>
<dt><a name="68">method <b class="cmd">keyword.class_method</b> <i class="arg">resultvar</i> <i class="arg">commentblock</i> <i class="arg">name</i> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd><p>Process a statement for a clay style class method</p></dd>
<dt><a name="69">method <b class="cmd">keyword.method</b> <i class="arg">resultvar</i> <i class="arg">commentblock</i> <i class="arg">name</i> <span class="opt">?<i class="arg">args</i>?</span></a></dt>
<dd><p>Process a statement for a tcloo style object method</p></dd>
<dt><a name="70">method <b class="cmd">keyword.proc</b> <i class="arg">commentblock</i> <i class="arg">name</i> <i class="arg">arglist</i> <i class="arg">body</i></a></dt>
<dd><p>Process a proc statement</p></dd>
<dt><a name="71">method <b class="cmd">reset</b></a></dt>
<dd><p>Reset the state of the object and its embedded coroutine</p></dd>
<dt><a name="72">method <b class="cmd">Main</b></a></dt>
<dd><p>Main body of the embedded coroutine for the object</p></dd>
<dt><a name="73">method <b class="cmd">section.method</b> <i class="arg">keyword</i> <i class="arg">method</i> <i class="arg">minfo</i></a></dt>
<dd><p>Generate the manual page text for a method or proc</p></dd>
<dt><a name="74">method <b class="cmd">section.class</b> <i class="arg">class_name</i> <i class="arg">class_info</i></a></dt>
<dd><p>Generate the manual page text for a class</p></dd>
<dt><a name="75">method <b class="cmd">section.command</b> <i class="arg">procinfo</i></a></dt>
<dd><p>Generate the manual page text for the commands section</p></dd>
<dt><a name="76">method <b class="cmd">manpage</b> <span class="opt">?<b class="option">header <em>value</em></b>?</span> <span class="opt">?<b class="option">footer <em>value</em></b>?</span> <span class="opt">?<b class="option">authors <em>list</em></b>?</span></a></dt>
<dd><p>Generate the manual page. Returns the completed text suitable for saving in .man file.
 The header argument is a block of doctools text to go in before the machine generated
 section. footer is a block of doctools text to go in after the machine generated
 section. authors is a list of individual authors and emails in the form of AUTHOR EMAIL ?AUTHOR EMAIL?...</p></dd>
<dt><a name="77">method <b class="cmd">scan_text</b> <i class="arg">text</i></a></dt>
<dd><p>Scan a block of text</p></dd>
<dt><a name="78">method <b class="cmd">scan_file</b> <i class="arg">filename</i></a></dt>
<dd><p>Scan a file of text</p></dd>
</dl>
</div>
</div>
<div id="section4" class="doctools_section"><h2><a name="section4">AUTHORS</a></h2>
<p>Sean Woods <a href="mailto:<yoda@etoyoc.com>">mailto:&lt;yoda@etoyoc.com&gt;</a></p>
</div>
<div id="section5" class="doctools_section"><h2><a name="section5">Bugs, Ideas, Feedback</a></h2>
<p>This document, and the package it describes, will undoubtedly contain
bugs and other problems.
Please report such in the category <em>oo</em> of the
<a href="http://core.tcl.tk/tcllib/reportlist">Tcllib Trackers</a>.
Please also report any ideas for enhancements you may have for either
package and/or documentation.</p>
<p>When proposing code changes, please provide <em>unified diffs</em>,
i.e the output of <b class="const">diff -u</b>.</p>
<p>Note further that <em>attachments</em> are strongly preferred over
inlined patches. Attachments can be made by going to the <b class="const">Edit</b>
form of the ticket immediately after its creation, and then using the
left-most button in the secondary navigation bar.</p>
</div>
<div id="keywords" class="doctools_section"><h2><a name="keywords">Keywords</a></h2>
<p>TclOO, oo</p>
</div>
<div id="category" class="doctools_section"><h2><a name="category">Category</a></h2>
<p>Programming tools</p>
</div>
<div id="copyright" class="doctools_section"><h2><a name="copyright">Copyright</a></h2>
<p>Copyright &copy; 2018 Sean Woods &lt;yoda@etoyoc.com&gt;</p>
</div>
</div></body></html>
